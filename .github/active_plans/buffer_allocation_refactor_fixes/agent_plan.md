# Buffer Allocation Refactor Fixes - Agent Implementation Plan

## Overview for Agents

This plan addresses three interconnected issues in the buffer allocation refactor:
1. Verifying and fixing buffer name/parameter name matching
2. Removing legacy ALL_BUFFER_LOCATION_PARAMETERS special handling
3. Fixing allocator limitations for cross-location aliasing

All changes must be minimal and surgical. The goal is to enable buffer location parameters to flow naturally through init and update paths without special-case logic.

## Component Descriptions

### Buffer Registry System
The `buffer_registry` module provides centralized buffer metadata management:
- **BufferRegistry**: Package-level singleton tracking all parent-buffer relationships
- **BufferGroup**: Container for all buffers belonging to a single parent factory
- **CUDABuffer**: Immutable buffer descriptor with name, size, location, aliasing info
- **Allocator Functions**: CUDA device functions generated by `build_allocator()` that allocate buffers at runtime

### Integration Points
Location parameters must flow through:
1. **Init Path**: User API → Solver → SingleIntegratorRun → SingleIntegratorRunCore → IVPLoop → buffer_registry.register()
2. **Update Path**: Solver.update() → SingleIntegratorRunCore.update() → loop.update() / step.update() → buffer_registry.update()

### Expected Behavior

**Buffer Registration:**
```python
buffer_registry.register(
    name='state',           # Buffer name
    parent=self,           # Parent factory instance
    size=n_states,         # Number of elements
    location='shared',     # 'shared' or 'local'
    persistent=False,      # If True with local, use persistent local
    precision=np.float32   # NumPy precision type
)
```

**Buffer Update:**
```python
# User calls: solver.update(state_location='local')
# Flows to: buffer_registry.update(parent, state_location='local')
# Registry strips '_location' suffix to find buffer name 'state'
# Updates buffer 'state' to location='local'
```

**Critical Requirement:** Buffer name must match parameter name prefix. If buffer is named "state", parameter MUST be "state_location". If buffer is named "proposed_state", parameter MUST be "proposed_state_location".

### Data Structures

**Current Allocator Signature:**
```python
@cuda.jit(device=True, inline=True)
def allocate_buffer(shared_parent, persistent_parent):
    if _use_shared:
        array = shared_parent[_shared_slice]
    elif _use_persistent:
        array = persistent_parent[_persistent_slice]
    else:
        array = cuda.local.array(_local_size, _precision)
    return array
```

**Problem:** No way to allocate fresh shared memory when parent is local but child is shared.

**Target Allocator Signature:**
```python
@cuda.jit(device=True, inline=True)
def allocate_buffer(shared_parent, persistent_parent, shared_fallback):
    if _use_shared:
        array = shared_parent[_shared_slice]
    elif _use_persistent:
        array = persistent_parent[_persistent_slice]
    elif _use_shared_fallback:
        array = shared_fallback[_shared_fallback_slice]
    else:
        array = cuda.local.array(_local_size, _precision)
    return array
```

### Dependencies
- buffer_registry.py provides allocation infrastructure
- All CUDAFactory subclasses register buffers and call get_allocator()
- Loop, algorithms, and solvers all participate in registration and allocation

## Architectural Changes Required

### Change 1: Buffer Name Audit and Correction
**Affected Components:**
- IVPLoop buffer registrations (ode_loop.py)
- Algorithm buffer registrations (various algorithms/*.py)
- Matrix-free solver buffer registrations (newton_krylov.py, linear_solver.py)

**Current State:**
- Some buffers use inconsistent naming (e.g., "proposed_state" buffer with "state_proposal_location" parameter)
- This causes silent failures where user-specified locations don't apply

**Target State:**
- All buffer names match parameter name prefixes exactly
- "proposed_state" buffer → "proposed_state_location" parameter
- "newton_delta" buffer → "delta_location" parameter (NOT "newton_delta_location")

**Note:** Buffer names themselves may NOT need changing if they're already used consistently in device code. The parameter names must match the buffer names.

### Change 2: Remove ALL_BUFFER_LOCATION_PARAMETERS
**Affected Components:**
- SingleIntegratorRunCore.py (lines 32-44, 355-361)

**Current Behavior:**
```python
ALL_BUFFER_LOCATION_PARAMETERS = {
    "state_location",
    "state_proposal_location",  # Inconsistent with buffer name!
    # ... etc
}

# In instantiate_loop():
buffer_location_kwargs = {
    key: loop_settings[key]
    for key in ALL_BUFFER_LOCATION_PARAMETERS
    if key in loop_settings
}
```

**Target Behavior:**
```python
# No special constant needed
# In instantiate_loop():
# Location parameters just pass through like any other parameter
loop_kwargs.update(**loop_settings)  # Natural flow
```

**Integration:** Location parameters should propagate via natural kwarg flow:
1. User specifies `state_location='shared'` to Solver.__init__
2. Flows to SingleIntegratorRunCore.__init__ in loop_settings dict
3. Flows to IVPLoop.__init__ as keyword argument
4. IVPLoop.__init__ passes to buffer_registry.register()

### Change 3: Three-Parameter Allocator Architecture
**Affected Components:**
- buffer_registry.py: CUDABuffer.build_allocator() method
- buffer_registry.py: BufferGroup.build_shared_layout() method  
- All factories that call buffer_registry.get_allocator()

**Current Limitation:**
Allocator can only slice from shared_parent OR persistent_parent. Cannot allocate fresh shared memory when:
- Parent is local but child is shared
- Parent is shared but has insufficient space for child

**Target Architecture:**
1. Add `shared_fallback_slice` parameter to build_allocator()
2. Allocator uses three compile-time paths:
   - `_use_shared`: Slice from shared_parent (aliasing parent)
   - `_use_persistent`: Slice from persistent_parent (aliasing parent)
   - `_use_shared_fallback`: Slice from shared_fallback (new shared allocation)
   - Else: cuda.local.array() (new local allocation)
3. build_shared_layout() computes both parent-aliasing slices AND fallback slices
4. get_allocator() provides appropriate slices based on buffer's actual allocation

**Aliasing Logic Enhancement:**
```python
# In build_shared_layout():
for name, entry in self.entries.items():
    if entry.aliases is not None:
        parent_entry = self.entries[entry.aliases]
        
        if parent_entry.is_shared and entry.is_shared:
            # Try to alias parent
            consumed = self._alias_consumption.get(entry.aliases, 0)
            available = parent_entry.size - consumed
            
            if entry.size <= available:
                # Alias within parent (use shared_parent parameter)
                parent_slice = layout[entry.aliases]
                start = parent_slice.start + consumed
                layout[name] = slice(start, start + entry.size)
                self._alias_consumption[entry.aliases] = consumed + entry.size
            else:
                # Allocate NEW shared space (use shared_fallback parameter)
                fallback_layout[name] = slice(fallback_offset, 
                                             fallback_offset + entry.size)
                fallback_offset += entry.size
        elif entry.is_shared:
            # Parent is local, allocate NEW shared space
            fallback_layout[name] = slice(fallback_offset,
                                         fallback_offset + entry.size)
            fallback_offset += entry.size
```

## Edge Cases to Consider

### Edge Case 1: Buffer Name with Multiple Suffixes
**Scenario:** Buffer named "newton_stage_base_bt"  
**Expected Parameter:** "stage_base_bt_location" (NOT "newton_stage_base_bt_location")  
**Handling:** Each factory should use buffer names without factory prefixes when the buffer is internal to that factory

### Edge Case 2: Proposed vs Proposal Naming
**Scenario:** "proposed_state" vs "state_proposal"  
**Current State:** Inconsistent usage in codebase  
**Resolution:** Standardize on ONE convention (likely "proposed_*" based on code review)

### Edge Case 3: Child Buffer Larger Than Parent
**Scenario:** Child requests aliasing but is larger than parent  
**Expected:** Child gets new allocation in its specified location  
**Current Behavior:** Already handled correctly by build_shared_layout()

### Edge Case 4: Multiple Levels of Aliasing
**Scenario:** Buffer C aliases Buffer B which aliases Buffer A  
**Expected:** Not currently supported; aliasing only works one level deep  
**Handling:** Document limitation or add error check

### Edge Case 5: Update After Build
**Scenario:** User calls solver.update(state_location='shared') after solve()  
**Expected:** Cache invalidates, next solve() rebuilds with new location  
**Current Behavior:** buffer_registry.update() invalidates layouts, CUDAFactory cache invalidation should trigger rebuild

## Data Flow Diagrams

### Init Path Data Flow
```
User API (solve_ivp / Solver.__init__)
    ↓ [kwargs: state_location='shared']
SingleIntegratorRun.__init__
    ↓ [kwargs passed to core]
SingleIntegratorRunCore.__init__
    ↓ [loop_settings dict with state_location='shared']
instantiate_loop(loop_settings=...)
    ↓ [**loop_settings unpacked]
IVPLoop.__init__(state_location='shared')
    ↓ [direct parameter]
buffer_registry.register('state', self, n_states, location=state_location)
    ↓
BufferGroup.register() stores CUDABuffer(location='shared')
```

### Update Path Data Flow
```
Solver.update(state_location='local')
    ↓ [kwargs with state_location='local']
SingleIntegratorRunCore.update(updates_dict={...})
    ↓ [passes to child components]
IVPLoop.update(updates_dict={...})
    ↓ [calls registry]
buffer_registry.update(self, updates_dict={...})
    ↓ [strips '_location' suffix]
BufferGroup.update_buffer('state', location='local')
    ↓
Invalidates layouts, marks cache invalid
```

### Build Path with Allocators
```
IVPLoop.build()
    ↓ [requests allocators]
buffer_registry.get_allocator('state', self)
    ↓
BufferGroup.get_allocator('state')
    ↓ [ensures layouts computed]
build_shared_layout() / build_persistent_layout()
    ↓ [computes slices or fallback]
entry.build_allocator(shared_slice, persistent_slice, fallback_slice)
    ↓
Returns compiled CUDA device function
```

## Implementation Task Groups

### Task Group 1: Buffer Name Audit
**Priority:** CRITICAL - Must be done first to identify all mismatches

**Tasks:**
1. Extract all buffer names from all buffer_registry.register() calls
2. Create mapping: buffer_name → expected_parameter_name (append "_location")
3. Search codebase for actual parameter usage
4. Identify mismatches (e.g., "proposed_state" vs "state_proposal_location")
5. Document all findings

**Deliverable:** Comprehensive list of name mismatches requiring correction

### Task Group 2: Fix Buffer/Parameter Name Mismatches
**Priority:** CRITICAL - Required for update() to work correctly

**Tasks:**
1. For each mismatch identified in Task Group 1:
   - Decide whether to rename buffer or parameter
   - Update buffer_registry.register() call if renaming buffer
   - Update ALL parameter references if renaming parameter
2. Verify ALL_BUFFER_LOCATION_PARAMETERS includes corrected names
3. Update IVPLoop.__init__ signature if needed
4. Update algorithm __init__ signatures if needed

**Deliverable:** All buffer names match their parameter names exactly

### Task Group 3: Remove ALL_BUFFER_LOCATION_PARAMETERS
**Priority:** HIGH - Simplifies architecture

**Tasks:**
1. Remove ALL_BUFFER_LOCATION_PARAMETERS constant from SingleIntegratorRunCore.py
2. Remove filtering logic in instantiate_loop() (lines 353-361)
3. Change loop_kwargs to include location parameters naturally
4. Verify location parameters pass through to IVPLoop.__init__
5. Test that buffer locations are set correctly on init

**Deliverable:** Location parameters flow naturally without special filtering

### Task Group 4: Three-Parameter Allocator Implementation
**Priority:** HIGH - Enables full aliasing support

**Sub-tasks:**

**4.1: Modify build_allocator() Signature**
- Add `shared_fallback_slice` parameter to CUDABuffer.build_allocator()
- Add `_use_shared_fallback` compile-time flag
- Add allocator path for shared_fallback

**4.2: Enhance build_shared_layout()**
- Compute both aliased slices AND fallback slices
- Return tuple: (aliased_layout, fallback_layout)
- Track which buffers use aliasing vs fallback

**4.3: Update get_allocator()**
- Provide three slice parameters to build_allocator():
  - shared_slice (if buffer aliases shared parent)
  - persistent_slice (if buffer aliases persistent parent)
  - shared_fallback_slice (if buffer needs new shared allocation)
- Ensure correct slices passed based on buffer configuration

**4.4: Update All Allocator Call Sites**
- Compiled device functions now receive three parent arrays
- Update IVPLoop.build() to pass shared_fallback array
- Update algorithm build() methods to pass shared_fallback array
- Update solver build() methods to pass shared_fallback array

**Deliverable:** Full cross-location aliasing support

### Task Group 5: Verification and Testing
**Priority:** CRITICAL - Validates all changes

**Tasks:**
1. Run existing tests: test_buffer_registry.py
2. Run existing tests: test_solver_buffer_locations.py
3. Add new test cases for cross-location aliasing if missing:
   - Parent shared, child shared (with and without space)
   - Parent local, child shared
   - Parent persistent, child persistent (with and without space)
4. Verify init path: buffer locations set correctly from solve_ivp kwargs
5. Verify update path: buffer locations update correctly from solver.update()
6. Run full integration test suite

**Deliverable:** All tests passing, aliasing scenarios validated

## Testing Requirements

### Unit Tests Required
1. **test_buffer_name_matching**: Verify all buffer names match parameter names
2. **test_cross_location_aliasing**: All aliasing scenarios from user stories
3. **test_location_parameter_propagation**: Init and update paths work correctly

### Integration Tests Required
1. **test_solver_init_with_locations**: solve_ivp and Solver.__init__ respect locations
2. **test_solver_update_locations**: solver.update() correctly updates buffer locations
3. **test_memory_usage**: Aliasing reduces memory footprint as expected

### Edge Case Tests Required
1. **test_child_larger_than_parent**: Child gets new allocation
2. **test_multiple_children_aliasing**: First-come-first-serve allocation
3. **test_update_after_build**: Cache invalidation triggers rebuild

## Dependencies Between Tasks

```
Task Group 1 (Audit)
    ↓
Task Group 2 (Fix Names) ← Must complete before removing filter
    ↓
Task Group 3 (Remove Filter) ← Can proceed once names are fixed
    ↓
Task Group 4 (Allocator) ← Independent but benefits from clean names
    ↓
Task Group 5 (Testing) ← Validates all changes
```

## Expected File Changes

### buffer_registry.py
- Modify CUDABuffer.build_allocator() to accept three slice parameters
- Enhance BufferGroup.build_shared_layout() to return aliased + fallback layouts
- Update BufferGroup.get_allocator() to provide three slices

### SingleIntegratorRunCore.py
- Remove ALL_BUFFER_LOCATION_PARAMETERS constant (line 32)
- Remove filtering logic in instantiate_loop() (lines 353-361)
- Natural kwarg flow for location parameters

### ode_loop.py
- Fix buffer name inconsistencies (proposed_state vs state_proposal)
- Verify all buffer names match IVPLoop.__init__ parameter names
- Update build() to handle three-parameter allocators

### algorithms/*.py
- Audit buffer names in all algorithm factories
- Ensure buffer names match parameter names
- Update build() methods for three-parameter allocators

### matrix_free_solvers/*.py
- Verify newton_krylov.py buffer names match parameters
- Verify linear_solver.py buffer names match parameters
- Update build() methods for three-parameter allocators

## Success Criteria Summary

1. ✅ All buffer names match their parameter names exactly
2. ✅ NO ALL_BUFFER_LOCATION_PARAMETERS constant exists
3. ✅ Location parameters flow naturally through init chain
4. ✅ Location parameters update correctly through update chain
5. ✅ Cross-location aliasing works in all scenarios:
   - Parent shared + child shared (space available) → aliases parent
   - Parent shared + child shared (no space) → new shared allocation
   - Parent local + child shared → new shared allocation
   - Parent persistent + child persistent → aliases or new as appropriate
6. ✅ All existing tests pass
7. ✅ New aliasing tests added and passing
8. ✅ User can specify buffer locations via solve_ivp, Solver.__init__, Solver.solve, Solver.update
9. ✅ Buffer location updates trigger cache invalidation and rebuild

## Notes for Detailed Implementer

- **Naming Convention:** Prefer "proposed_*" over "*_proposal" for consistency
- **Buffer Prefixes:** Avoid factory-name prefixes in buffer names (e.g., "delta" not "newton_delta") when buffer is internal to factory
- **Three-Parameter Migration:** All allocator call sites must be updated simultaneously
- **Testing Strategy:** Implement aliasing tests BEFORE making allocator changes to establish baseline
- **Cache Invalidation:** Verify buffer_registry.update() calls invalidate_layouts() which triggers cache invalidation in CUDAFactory
