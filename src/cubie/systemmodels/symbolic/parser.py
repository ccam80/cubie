"""Parsing helpers for symbolic ODE definitions."""

import re
from typing import Dict, Iterable, Optional, Union
from warnings import warn

import sympy as sp
from sympy.parsing.sympy_parser import T, parse_expr

from .indexedbasemaps import IndexedBases
from .sym_utils import hash_system_definition

# Lambda notation, Auto-number, factorial notation, implicit multiplication
PARSE_TRANSORMS = (T[0][0],T[3][0], T[4][0], T[8][0])

class EquationWarning(Warning):
    pass

_func_call_re = re.compile(r"\b([A-Za-z_]\w*)\s*\(")

# ---------------------------- Input cleaning ------------------------------- #
def _sanitise_input_math(expr_str: str):
    """Replace constructs that are logical in python but not in Sympy."""
    expr_str = _replace_if(expr_str)
    return expr_str

def _replace_if(expr_str: str):
    match = re.search(r"(.+?) if (.+?) else (.+)", expr_str)
    if match:
        true_str = _replace_if(match.group(1).strip())
        cond_str = _replace_if(match.group(2).strip())
        false_str = _replace_if(match.group(3).strip())
        return f"Piecewise(({true_str}, {cond_str}), ({false_str}, True))"
    return expr_str

# -------------------------- Process equations ------------------------------ #
def _process_calls(equations_input: Iterable[str],
                   user_functions: Optional[Dict[str, callable]] = None):
    """ map known SymPy callables (e.g., 'exp') to Sympy functions """
    calls = set()
    if user_functions is None:
        user_functions = {}
    for line in equations_input:
        calls |= set(_func_call_re.findall(line))
    funcs = {}
    for name in calls:
        fn = getattr(sp, name, None)
        if fn is None:
            if name in user_functions:
                funcs[name] = user_functions[name]
            else:
                raise ValueError(f"Your dxdt code contains a call to a "
                                 f"function {name}() that isn't part of Sympy "
                                 f"and wasn't provided in the user_functions "
                                 f"dict.")
        elif callable(fn):
            funcs[name] = fn

    return funcs

def _process_parameters(states,
                        parameters,
                        constants,
                        observables,
                        drivers):
    """Process parameters and constants into indexed bases."""
    indexed_bases = IndexedBases.from_user_inputs(states,
                                                  parameters,
                                                  constants,
                                                  observables,
                                                  drivers)
    return indexed_bases


def _lhs_pass(
    lines,
    indexed_bases: IndexedBases,
    ) -> dict[str, sp.Symbol]:
    """ Process the left-hand-sides of all equations.

    Parameters
    ----------
    lines: list of str
        User-supplied list of equations that make up the dxdt function
    indexed_bases: IndexedBases
        The collection of maps from labels to indexed bases for the system
        generated by '_process_parameters'.

    Returns
    -------
    Anonymous Auxiliaries: dict
        Auxiliary(observable) variables that aren't defined in the
        observables dictionary.

    Notes
    -----
    It is assumed that anonymous auxiliaries were included to make
    model-writing easier, and they won't be saved, but we need to keep
    track of the symbols for the Sympy math used in code generation.
    """
    anonymous_auxiliaries = {}
    assigned_obs = set()
    underived_states = set(indexed_bases.dxdt_names)
    state_names = indexed_bases.state_names
    observable_names = indexed_bases.observable_names
    param_names = indexed_bases.parameter_names
    constant_names = indexed_bases.constant_names
    driver_names = indexed_bases.driver_names
    states = indexed_bases.states
    observables = indexed_bases.observables
    dxdt = indexed_bases.dxdt

    for line in lines:
        lhs, rhs = [p.strip() for p in line.split("=", 1)]
        if lhs.startswith("d"):
            state_name = lhs[1:]
            s_sym = sp.Symbol(state_name, real=True)
            if state_name not in state_names:
                if state_name in observable_names:
                    warn(
                        f"Your equation included d{state_name}, but "
                        f"{state_name} was listed as an observable. It has"
                        "been converted into a state.",
                        EquationWarning,
                    )
                    states.push(s_sym)
                    dxdt.push(s_sym)
                    observables.pop(s_sym)
                else:
                    ValueError(f"Unknown state derivative: {lhs}.")
                    f"No state or observable called {state_name} found."
            underived_states -= {lhs}

        elif lhs in state_names:
            raise ValueError(
                f"State {lhs} cannot be assigned directly. All "
                f"states must be defined as derivatives with d"
                f"{lhs} = [...]"
            )

        elif lhs in param_names or lhs in constant_names or lhs in driver_names:
            raise ValueError(
                f"{lhs} was entered as an immutable "
                f"input (constant, parameter, or driver)"
                ", but it is being assigned to. Cubie "
                "can't handle this - if it's being "
                "assigned to, it must be either a state, an "
                "observable, or undefined."
            )

        else:
            if lhs not in observable_names:
                warn(
                    f"The intermediate variable {lhs} was assigned to "
                    f"but not listed as an observable. It's trajectory will "
                    f"not be saved.",
                    EquationWarning,
                )
                anonymous_auxiliaries[lhs] = sp.Symbol(lhs, real=True)
            assigned_obs.add(lhs)

    missing_obs = set(indexed_bases.observable_names) - assigned_obs
    if missing_obs:
        raise ValueError(f"Observables {missing_obs} are never assigned "
                         f"to.")

    if underived_states:
        warn(
            f"States {underived_states} have no associated derivative "
            f"term. In the Cubie world, this makes it an 'observable'. "
            f"{underived_states} have been moved from states to observables.",
            EquationWarning,
        )
        for state in underived_states:
            s_sym = sp.Symbol(state, real=True)
            if state in observables:
                raise ValueError(
                    f"State {state} is already both observable and state. "
                    f"It needs to be an observable if it has no derivative"
                    f"term."
                )
            observables.push(s_sym)
            states.pop(s_sym)
            dxdt.pop(s_sym)

    return anonymous_auxiliaries

def _rhs_pass(lines: Iterable[str],
              all_symbols: Dict[str, sp.Symbol],
              user_funcs: Optional[Dict[str, callable]] = None):
    """Process expressions, checking symbols and finding callables.

    Parameters
    ----------
    lines: list of str
        User-supplied list of equations that make up the dxdt function
    all_symbols: dict
        All symbols defined in the model, including anonymous auxiliaries.

    Returns
    -------
    tuple of tuples of (sp.Symbol, sp.Expr), dict
    tuple of (lhs, rhs) expressions, dict of callable functions

    """
    expressions = []
    funcs = _process_calls(lines, user_funcs)
    all_symbols.update(funcs)
    for line in lines:
        lhs, rhs = [p.strip() for p in line.split("=", 1)]
        try:
            rhs_expr = _sanitise_input_math(rhs)
            rhs_expr = parse_expr(
                    rhs_expr,
                    transformations=PARSE_TRANSORMS,
                    local_dict=all_symbols)
        except (NameError, TypeError):
            raise ValueError(f"Undefined symbols in equation '{line}'")
        expressions.append([all_symbols[lhs], rhs_expr])

    return expressions, funcs

def parse_input(
        states: Union[Dict, Iterable[str]],
        observables: Iterable[str],
        parameters: Union[Dict, Iterable[str]],
        constants: Union[Dict, Iterable[str]],
        drivers: Iterable[str],
        user_functions: Optional[Dict[str, callable]] = None,
        dxdt = Union[str, Iterable[str]],
):
    """Create a :class:`SymbolicODE` from manual string input."""
    index_map = _process_parameters(states=states,
                                    parameters=parameters,
                                    constants=constants,
                                    observables=observables,
                                    drivers=drivers)

    if isinstance(dxdt, str):
        lines = [
            line.strip() for line in dxdt.strip().splitlines() if line.strip()
        ]
    elif isinstance(dxdt, list) or isinstance(dxdt, tuple):
        lines = [line.strip() for line in dxdt if line.strip()]
    else:
        raise ValueError("dxdt must be a string or a list/tuple of strings")

    constants = index_map.constants.default_values
    fn_hash = hash_system_definition(dxdt, constants)
    anon_aux = _lhs_pass(lines, index_map)
    all_symbols = index_map.all_symbols.copy()
    all_symbols.update(anon_aux)
    equation_map, funcs = _rhs_pass(lines=lines,
                             all_symbols=all_symbols,
                             user_funcs=user_functions)

    return index_map, all_symbols, funcs, equation_map, fn_hash
