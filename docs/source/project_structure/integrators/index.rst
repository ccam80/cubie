Integrators
===========

``cubie.integrators``
---------------------

.. currentmodule:: cubie.integrators

.. toctree::
   :hidden:
   :maxdepth: 1
   :titlesonly:

   single_integrator_run
   integrator_return_codes
   get_algorithm_step
   explicit_step_config
   implicit_step_config
   explicit_euler_step
   backwards_euler_step
   backwards_euler_pc_step
   crank_nicolson_step
   ivp_loop
   linear_solver_factory
   newton_krylov_solver_factory
   adaptive_i_controller
   adaptive_pi_controller
   adaptive_pid_controller
   fixed_step_controller
   gustafsson_controller
   get_controller

The :class:`SingleIntegratorRun` façade is the primary entry point. It creates a
loop callable by wiring controller, algorithm, and loop submodules according to
the supplied :class:`IntegratorRunSettings`.

The :mod:`cubie.integrators` package coordinates CUDA-based initial value
problem integrations. It bundles algorithm factories, controller builders,
matrix-free solver helpers, and loop orchestrators that combine CUDA device
functions from ODE systems with adaptive or fixed step control.

.. toctree::
   :maxdepth: 1
   :caption: Subpackages

   algorithms
   loops
   matrix_free_solvers
   step_control

Core API
--------

* :doc:`SingleIntegratorRun <single_integrator_run>` – high-level integration façade.
* :doc:`IntegratorReturnCodes <integrator_return_codes>` – enumerates loop exit statuses.

Factories and helpers
---------------------

* :doc:`get_algorithm_step <get_algorithm_step>` – retrieves CUDA step factories by name.
* :doc:`ExplicitStepConfig <explicit_step_config>` – attrs configuration for explicit schemes.
* :doc:`ImplicitStepConfig <implicit_step_config>` – attrs configuration for implicit schemes.
* :doc:`ExplicitEulerStep <explicit_euler_step>` – explicit Euler CUDA step implementation.
* :doc:`BackwardsEulerStep <backwards_euler_step>` – backward Euler CUDA step implementation.
* :doc:`BackwardsEulerPCStep <backwards_euler_pc_step>` – predictor-corrector backward Euler variant.
* :doc:`CrankNicolsonStep <crank_nicolson_step>` – Crank–Nicolson implicit step implementation.
* :doc:`IVPLoop <ivp_loop>` – builds compiled CUDA loops for IVP execution.
* :doc:`linear_solver_factory <linear_solver_factory>` – matrix-free linear solver factory.
* :doc:`newton_krylov_solver_factory <newton_krylov_solver_factory>` – Newton–Krylov solver factory.
* :doc:`AdaptiveIController <adaptive_i_controller>` – integral adaptive step controller.
* :doc:`AdaptivePIController <adaptive_pi_controller>` – proportional-integral controller.
* :doc:`AdaptivePIDController <adaptive_pid_controller>` – proportional-integral-derivative controller.
* :doc:`FixedStepController <fixed_step_controller>` – no-op step controller for fixed steps.
* :doc:`GustafssonController <gustafsson_controller>` – Gustafsson adaptive controller variant.
* :doc:`get_controller <get_controller>` – factory that resolves controller instances.

Dependencies
------------

- Implicit algorithms obtain Newton--Krylov helpers from
  :mod:`cubie.integrators.matrix_free_solvers` via ``get_solver_helper_fn``
  closures.
- Loop factories depend on :mod:`cubie.outputhandling` for compile flags and
  saving callbacks generated by
  :class:`cubie.outputhandling.output_functions.OutputFunctions`.
- Controllers operate alongside algorithm step objects exposed by
  :mod:`cubie.integrators.algorithms` to manage adaptive step sizes.
